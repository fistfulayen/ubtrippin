# PRD 022 Phase 1 — RLS Audit: Eliminate createSecretClient from User-Facing Code

## The Problem

Nearly every API v1 route and several dashboard pages use `createSecretClient()` (service role) for all database queries. This bypasses Row Level Security entirely. The auth middleware validates the user, then the route queries the DB as god mode. If any route has a bug (e.g., missing `user_id` filter), it leaks data across users.

## The Fix: User-Scoped Client for API Routes

Create a new helper `createUserScopedClient(userId: string)` in `src/lib/supabase/server.ts` that:

1. Creates a Supabase client with the service role key (needed to set config)
2. Immediately calls `supabase.rpc('set_claim', { uid: userId })` or uses `supabase.auth.admin.getUserById()` 

Actually, the cleanest Supabase pattern is:

```typescript
import { createClient } from '@supabase/supabase-js'

export function createUserScopedClient(userId: string) {
  const supabase = createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SECRET_KEY!,
    {
      global: {
        headers: {
          // This makes RLS see this user as authenticated
          Authorization: `Bearer ${process.env.SUPABASE_SECRET_KEY}`,
        },
      },
      db: {
        schema: 'public',
      },
    }
  )
  
  // Set the requesting user for RLS policies that check auth.uid()
  // This uses set_config which lasts for the transaction/session
  return { supabase, userId }
}
```

Wait — the correct Supabase approach for API-key auth with RLS is to **impersonate** the user. Use this pattern:

```typescript
import { createClient } from '@supabase/supabase-js'

export function createUserClient(userId: string) {
  // Create a client that respects RLS as if this user were logged in
  // We use the service role but set request.jwt.claims via headers
  const client = createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_PUBLISHABLE_KEY!,  // Use anon/publishable key
    {
      global: {
        headers: {
          // Impersonate the user for RLS
          'x-supabase-auth': userId,
        },
      },
    }
  )
  return client
}
```

Hmm, neither of those is quite right. The **actual** correct pattern is:

### Option A: SQL-level RLS with `set_config` (recommended)

Create a Postgres function:
```sql
CREATE OR REPLACE FUNCTION set_request_user(user_id uuid)
RETURNS void AS $$
BEGIN
  PERFORM set_config('request.jwt.claims', json_build_object('sub', user_id)::text, true);
  PERFORM set_config('request.jwt.claim.sub', user_id::text, true);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

Then in `src/lib/supabase/user-scoped.ts`:
```typescript
import { createClient } from '@supabase/supabase-js'

export async function createUserScopedClient(userId: string) {
  const supabase = createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SECRET_KEY!
  )
  
  // Set the user context for RLS policies
  await supabase.rpc('set_request_user', { user_id: userId })
  
  return supabase
}
```

**Important:** This uses the service role key but SETS the JWT claims so RLS policies that check `auth.uid()` will see the correct user. The RLS still enforces access — we're not bypassing it, we're telling it who we are.

### What to Change

**Step 1:** Create the migration `supabase/migrations/YYYYMMDD_set_request_user.sql` with the `set_request_user` function.

**Step 2:** Create `src/lib/supabase/user-scoped.ts` with the `createUserScopedClient` function.

**Step 3:** In `src/lib/api/auth.ts`, keep `createSecretClient()` ONLY for the API key lookup (line 63). This is legitimate — we need service role to find the key before we know the user.

**Step 4:** In every API v1 route handler, replace:
```typescript
const supabase = createSecretClient()
```
with:
```typescript
const supabase = await createUserScopedClient(auth.userId)
```

The `auth` variable is already available in every route handler from `validateApiKey()`.

**Step 5:** For dashboard pages (`src/app/(dashboard)/*`), switch to `createClient()` from `src/lib/supabase/server.ts` (cookie-based auth). These already have user sessions from the browser.

**Step 6:** For public share pages (`src/app/share/[token]/page.tsx`, `src/app/guide/[token]/page.tsx`), keep `createSecretClient()` — these are unauthenticated and need service role to look up by token. But verify they ONLY query the specific shared item, never cross-reference user data.

**Step 7:** For webhook routes (`src/app/api/webhooks/resend/route.ts`, `src/app/api/v1/webhooks/stripe/route.ts`), keep `createSecretClient()` — these are server-to-server with no user context. They verify via HMAC/Stripe signature.

**Step 8:** For `src/lib/` files called from user routes (limits.ts, activation.ts, loyalty-flag.ts, example-selection.ts), refactor to accept a Supabase client parameter instead of creating their own:
```typescript
// Before:
export async function checkTripLimit(userId: string) {
  const supabase = createSecretClient()
  // ...
}

// After:
export async function checkTripLimit(supabase: SupabaseClient, userId: string) {
  // use the passed-in client (which may be user-scoped)
  // ...
}
```

### Legitimate Uses of createSecretClient (DO NOT CHANGE)

- `src/lib/api/auth.ts` line 63 — API key lookup (pre-auth)
- `src/app/api/internal/*` — all internal routes (cron, webhook processing)
- `src/app/api/webhooks/stripe/route.ts` — Stripe webhook (no user context, HMAC verified)
- `src/app/api/webhooks/resend/route.ts` — Resend webhook (no user context, signature verified)
- `src/app/share/[token]/page.tsx` — public share page (no auth, query by token)
- `src/app/guide/[token]/page.tsx` — public guide share page (same)
- `src/app/api/calendar/feed/route.ts` — calendar feed (auth by token, not user session)
- `src/lib/webhooks.ts` — webhook delivery engine (cron context)
- `src/lib/nudge-emails.ts` — email nudge system (cron context)

### Validation

1. `npx tsc --noEmit` must pass
2. `pnpm build` must compile (may fail on missing env vars — that's OK)
3. `grep -rn createSecretClient src/app/ --include='*.ts' --include='*.tsx' | grep -v /api/internal/ | grep -v /api/webhooks/ | grep -v /share/ | grep -v /guide/ | grep -v /api/calendar/feed/` should return ONLY the auth.ts API key lookup
4. All existing E2E tests must still pass (don't change behavior, just change HOW we query)

### DO NOT
- Do NOT use `createSecretClient()` or service role to bypass RLS in user-facing routes. Fix RLS policies instead. This code will be security-audited monthly.
- Do NOT change the public API contract (request/response shapes)
- Do NOT modify RLS policies unless absolutely necessary for the migration
- Do NOT change auth.ts beyond keeping the one legitimate usage
